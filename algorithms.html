<cxx-clause id="parallel.alg">
  <h1>Parallel algorithms</h1>

  <cxx-section id="parallel.alg.wavefront">
    <h1>Wavefront Application</h1>
    <p>
      For the purposes of this section, an <i>evaluation</i> is a value computation or side effect of
      an expression, or an execution of a statement. Initialization of a temporary object is considered a
      subexpression of the expression that necessitates the temporary object.
    </p>

    <p>
      An evaluation A <i>contains</i> an evaluation B if:

      <ul>
      <li>A and B are not potentially concurrent ([intro.races]); and</li>
      <li>the start of A is the start of B or the start of A is sequenced before the start of B; and</li>
      <li>the completion of B is the completion of A or the completion of B is sequenced before the completion of A.</li>
      </ul>

      <cxx-note>This includes evaluations occurring in function invocations.</cxx-note>
    <!-/p ->

    <p>
      An evaluation A is <i>ordered before</i> an evaluation B if A is deterministically
      sequenced before B. <cxx-note>If A is indeterminately sequenced with respect to B
      or A and B are unsequenced, then A is not ordered before B and B is not ordered
      before A. The ordered before relationship is transitive.</cxx-note>
    </p>

    <p>
      For an evaluation A ordered before an evaluation B, both contained in the same
      invocation of an element access function, A is a <i>vertical antecedent</i> of B if:

      <ul>
      <li>there exists an evaluation S such that:
        <ul>
          <li>S contains A, and</li>
          <li>S contains all evaluations C (if any) such that A is ordered before C and C is ordered before B,</li>
          <li>but S does not contain B, and</li>
        </ul>
      </li>
      <li>
        control reached B from A without executing any of the following:
        <ul>
          <li>a <code>goto</code> statement or <code>asm</code> declaration that jumps to a statement outside of S, or</li>
          <li>a <code>switch</code> statement executed within S that transfers control into a substatement of a nested selection or iteration statement, or</li>
          <li>a <code>throw</code> <cxx-note>even if caught</cxx-note>, or</li>
          <li>a <code>longjmp</code>.
        </ul>
      </li>
      </ul>

      <cxx-note>
        Vertical antecedent is an irreflexive, antisymmetric, nontransitive relationship between two evaluations.
        Informally, A is a vertical antecedent of B if A is sequenced immediately before B or A is nested zero or
        more levels within a statement S that immediately precedes B.
      </cxx-note>
    <!-/p ->

    <p>
      In the following, <i>X<sub>i</sub></i> and <i>X<sub>j</sub></i> refer to evaluations of the <i>same</i> expression
      or statement contained in the application of an element access function corresponding to the i<sup>th</sup> and
      j<sup>th</sup> elements of the input sequence. <cxx-note>There might be several evaluations <i>X<sub>k</sub></i>,
      <i>Y<sub>k</sub></i>, etc. of a single expression or statement in application <i>k</i>, for example, if the
      expression or statement appears in a loop within the element access function.</cxx-note>
    </p>

    <p>
      <i>Horizontally matched</i> is an equivalence relationship between two evaluations of the same expression. An
      evaluation B<sub>i</sub> is <i>horizontally matched</i> with an evaluation B<sub>j</sub> if:

      <ul>
        <li>both are the first evaluations in their respective applications of the element access function, or</li>
        <li>there exist horizontally matched evaluations A<sub>i</sub> and A<sub>j</sub> that are vertical antecedents of evaluations B<sub>i</sub> and B<sub>j</sub>, respectively.
      </ul>

      <cxx-note>
        <i>Horizontally matched</i> establishes a theoretical <i>lock-step</i> relationship between evaluations in different applications of an element access function.
      </cxx-note>

    <p>
      Let <i>f</i> be a function called for each argument list in a sequence of argument lists.
      <i>Wavefront application</i> of <i>f</i> requires that evaluation A<sub>i</sub> be sequenced
      before evaluation B<sub>j</sub> if i &lt; j and:

      <ul>
        <li>A<sub>i</sub> is sequenced before some evaluation B<sub>i</sub> and B<sub>i</sub> is horizontally matched with B<sub>j</sub>, or</li>
        <li>A<sub>i</sub> is horizontally matched with some evaluation A<sub>j</sub> and A<sub>j</sub> is sequenced before B<sub>j<sub>.</li>
      </ul>

      <cxx-note>
        <i>Wavefront application</i> guarantees that parallel applications i and j execute such that progress on application j never gets <i>ahead</i> of application i.
      </cxx-note>

      <cxx-note>
        The relationships between A<sub>i</sub> and B<sub>i</sub> and between A<sub>j</sub> and B<sub>j</sub> are <i>sequenced before</i>, not <i>vertical antecedent</i>.
      </cxx-note>
  </cxx-section>

  <cxx-section id="parallel.alg.ops">
    <h1>Non-Numeric Parallel Algorithms</h1>

    <cxx-section id="parallel.alg.ops.synopsis">
      <h1>Header <code>&lt;experimental/algorithm&gt;</code> synopsis</h1>

      <pre>
#include &lt;algorithm&gt;

namespace std::experimental {
inline namespace parallelism_v2 {
namespace execution {
  <cxx-ref insynopsis="" to="parallel.alg.novec"></cxx-ref>
  template&lt;class F&gt;
    auto no_vec(F&amp;&amp; f) noexcept -&gt; decltype(std::forward&lt;F&gt;(f)());

  <cxx-ref insynopsis="" to="parallel.alg.ordupdate.class"></cxx-ref>
  template&lt;class T&gt;
    class ordered_update_t;

  <cxx-ref insynopsis="" to="parallel.alg.ordupdate.func"></cxx-ref>
  template&lt;class T&gt;
    ordered_update_t&lt;T&gt; ordered_update(T&amp; ref) noexcept;
}

// Exposition only: Suppress template argument deduction.
template&lt;class T&gt; struct no_deduce { using type = T; };
template&lt;class T&gt; using no_deduce_t = typename no_deduce&lt;T&gt;::type;

<cxx-ref insynopsis="" to="parallel.alg.reductions"></cxx-ref> Support for reductions
template&lt;class T, class BinaryOperation&gt;
  <em>unspecified</em> reduction(T&amp; var, const T&amp; identity, BinaryOperation combiner);
template&lt;class T&gt;
  <em>unspecified</em> reduction_plus(T&amp; var);
template&lt;class T&gt;
  <em>unspecified</em> reduction_multiplies(T&amp; var);
template&lt;class T&gt;
  <em>unspecified</em> reduction_bit_and(T&amp; var);
template&lt;class T&gt;
  <em>unspecified</em> reduction_bit_or(T&amp; var);
template&lt;class T&gt;
  <em>unspecified</em> reduction_bit_xor(T&amp; var);
template&lt;class T&gt;
  <em>unspecified</em> reduction_min(T&amp; var);
template&lt;class T&gt;
  <em>unspecified</em> reduction_max(T&amp; var);

<cxx-ref insynopsis="" to="parallel.alg.inductions"></cxx-ref> Support for inductions
template&lt;class T&gt;
  <em>unspecified</em> induction(T&amp;&amp; var);
template&lt;class T<ins>, class S</ins>&gt;
  <em>unspecified</em> induction(T&amp;&amp; var, S stride);

<cxx-ref insynopsis="" to="parallel.alg.forloop"></cxx-ref> for_loop
template&lt;class I, class... Rest&gt;
  void for_loop(no_deduce_t&lt;I&gt; start, I finish, Rest&amp;&amp;... rest);
template&lt;class ExecutionPolicy,
         class I, class... Rest&gt;
  void for_loop(ExecutionPolicy&amp;&amp; exec,
                no_deduce_t&lt;I&gt; start, I finish, Rest&amp;&amp;... rest);
template&lt;class I, class S, class... Rest&gt;
  void for_loop_strided(no_deduce_t&lt;I&gt; start, I finish,
                        S stride, Rest&amp;&amp;... rest);
template&lt;class ExecutionPolicy,
         class I, class S, class... Rest&gt;
  void for_loop_strided(ExecutionPolicy&amp;&amp; exec,
                        no_deduce_t&lt;I&gt; start, I finish,
                        S stride, Rest&amp;&amp;... rest);
template&lt;class I, class Size, class... Rest&gt;
  void for_loop_n(I start, Size n, Rest&amp;&amp;... rest);
template&lt;class ExecutionPolicy,
         class I, class Size, class... Rest&gt;
  void for_loop_n(ExecutionPolicy&amp;&amp; exec,
                  I start, Size n, Rest&amp;&amp;... rest);
template&lt;class I, class Size, class S, class... Rest&gt;
  void for_loop_n_strided(I start, Size n, S stride, Rest&amp;&amp;... rest);
template&lt;class ExecutionPolicy,
         class I, class Size, class S, class... Rest&gt;
  void for_loop_n_strided(ExecutionPolicy&amp;&amp; exec,
                          I start, Size n, S stride, Rest&amp;&amp;... rest);
}
}
</pre>
    </cxx-section>

    <cxx-section id="parallel.alg.reductions">
      <h1>Reductions</h1>

      <p>
        Each of the function templates in this subclause ([parallel.alg.reductions]) returns a <em>reduction object</em>
        of unspecified type having a <em>reduction value type</em> and encapsulating a <em>reduction identity</em> value for the reduction, a
        <em>combiner</em> function object, and a <em>live-out object</em> from which the initial value is obtained and into which the final
        value is stored.
      </p>

      <p>
        An algorithm uses reduction objects by allocating an unspecified number of instances, known as <em>accumulators</em>, of the reduction value
        type. <cxx-note>An implementation might, for example, allocate an accumulator for each thread in its private thread pool.</cxx-note>
        Each accumulator is initialized with the objectâ€™s reduction identity, except that the live-out object (which was initialized by the
        caller) comprises one of the accumulators. The algorithm passes a reference to an accumulator to each application of an element-access
        function, ensuring that no two concurrently executing invocations share the same accumulator. An accumulator can be shared between two
        applications that do not execute concurrently, but initialization is performed only once per accumulator.
      </p>

      <p>
        Modifications to the accumulator by the application of element access functions accrue as partial results. At some point before the algorithm
        returns, the partial results are combined, two at a time, using the reduction objectâ€™s combiner operation until a single value remains, which
        is then assigned back to the live-out object. <cxx-note> in order to produce useful results, modifications to the accumulator should be limited
        to commutative operations closely related to the combiner operation. For example if the combiner is <code>plus&lt;T&gt;</code>, incrementing
        the accumulator would be consistent with the combiner but doubling it or assigning to it would not.</cxx-note>
      </p>

      <cxx-function>
        <cxx-signature>template&lt;class T, class BinaryOperation&gt;
<em>unspecified</em> reduction(T&amp; var, const T&amp; identity, BinaryOperation combiner);</cxx-signature>

        <cxx-requires>T shall meet the requirements of <code>CopyConstructible</code> and <code>MoveAssignable</code>. The expression <code>var = combiner(var, var)</code> shall be well-formed.</cxx-requires>

        <cxx-returns><ins>A</ins><del>a</del> reduction object of unspecified type having reduction value type <code>T</code>, reduction identity <code>identity</code>, combiner function object <code>combiner</code>, and using the object referenced by <code>var</code> as its live-out object.</cxx-returns>
      </cxx-function>

      <cxx-function>
        <cxx-signature>template&lt;class T&gt;
<em>unspecified</em> reduction_plus(T&amp; var);</cxx-signature>
        <cxx-signature>template&lt;class T&gt;
<em>unspecified</em> reduction_multiplies(T&amp; var);</cxx-signature>
        <cxx-signature>template&lt;class T&gt;
<em>unspecified</em> reduction_bit_and(T&amp; var);</cxx-signature>
        <cxx-signature>template&lt;class T&gt;
<em>unspecified</em> reduction_bit_or(T&amp; var);</cxx-signature>
        <cxx-signature>template&lt;class T&gt;
<em>unspecified</em> reduction_bit_xor(T&amp; var);</cxx-signature>
        <cxx-signature>template&lt;class T&gt;
<em>unspecified</em> reduction_min(T&amp; var);</cxx-signature>
        <cxx-signature>template&lt;class T&gt;
<em>unspecified</em> reduction_max(T&amp; var);</cxx-signature>

        <cxx-requires>T shall meet the requirements of <code>CopyConstructible</code> and <code>MoveAssignable</code>.</cxx-requires>

        <cxx-returns><ins>A</ins><del>a</del> reduction object of unspecified type having reduction value type <code>T</code>, reduction identity and combiner operation as specified in table <cxx-ref to="reduction-identities-and-combiner-operations"></cxx-ref> and using the object referenced by <code>var</code> as its live-out object.</cxx-returns>

        <table is="cxx-table" class="column-rules" id=reduction-identities-and-combiner-operations>
          <caption>Reduction identities and combiner operations</caption>
          <thead>
            <tr>
              <th>Function</th>
              <th>Reduction Identity</th>
              <th>Combiner Operation</th>
            </tr>
            <tr>
              <th><code>reduction_plus</code></th>
              <th><code>T()</code></th>
              <th><code>x + y</code></th>
            </tr>
            <tr>
              <th><code>reduction_multiplies</code></th>
              <th><code>T(1)</code></th>
              <th><code>x * y</code></th>
            </tr>
            <tr>
              <th><code>reduction_bit_and</code></th>
              <th><code>(~T())</code></th>
              <th><code>X &amp; y</code></th>
            </tr>
            <tr>
              <th><code>reduction_bit_or</code></th>
              <th><code>T()</code></th>
              <th><code>x | y</code></th>
            </tr>
            <tr>
              <th><code>reduction_bit_xor</code></th>
              <th><code>T()</code></th>
              <th><code>x ^ y</code></th>
            </tr>
            <tr>
              <th><code>reduction_min</code></th>
              <th><code>var</code></th>
              <th><code>min(x, y)</code></th>
            </tr>
            <tr>
              <th><code>reduction_max</code></th>
              <th><code>var</code></th>
              <th><code>max(x, y)</code></th>
            </tr>
          </thead>
        </table>

        <cxx-example>The following code updates each element of <code>y</code> and sets <code>s</code> to the sum of the squares.
<pre>
extern int n;
extern float x[], y[], a;
float s = 0;
for_loop(execution::vec, 0, n,
    reduction(s, 0.0f, plus&lt;&gt;()),
    [&amp;](int i, float&amp; accum) {
            y[i] += a*x[i];
            accum += y[i]*y[i];
    }
);
</pre>
        </cxx-example>
      </cxx-function>
    </cxx-section>

    <cxx-section id="parallel.alg.inductions">
      <h1>Inductions</h1>

      <p>
        Each of the function templates in this section return an <em>induction object</em> of unspecified type having an <em>induction
        value type</em> and encapsulating an initial value <em>i</em> of that type and, optionally, a <em>stride</em>.
      </p>

      <p>
        For each element in the input range, an algorithm over input sequence <em>S</em> computes an <em>induction value</em> from an induction variable
        and ordinal position <em>p</em> within <em>S</em> by the formula <em>i + p * stride</em> if a stride was specified or <em>i + p</em> otherwise. This induction value is
        passed to the element access function.
      </p>

      <p>
        An induction object may refer to a <em>live-out</em> object to hold the final value of the induction sequence. When the algorithm using the induction
        object completes, the live-out object is assigned the value <em>i + n * stride</em>, where <em>n</em> is the number of elements in the input range.
      </p>

      <cxx-function>
        <cxx-signature>template&lt;class T&gt;
<em>unspecified</em> induction(T&amp;&amp; var);</cxx-signature>

        <cxx-signature>template&lt;class T, class S&gt;
<em>unspecified</em> induction(T&amp;&amp; var, S stride);</cxx-signature>

        <cxx-returns>
          <ins>A</ins><del>a</del>n induction object with induction value type <code>remove_cv_t&lt;remove_reference_t&lt;T&gt;&gt;</code>,
          initial value <code>var</code>, and (if specified) stride <code>stride</code>. If <code>T</code> is an lvalue reference
          to non-<code>const</code> type, then the object referenced by <code>var</code> becomes the live-out object for the
          induction object; otherwise there is no live-out object.
        </cxx-returns>
      </cxx-function>
    </cxx-section>

    <cxx-section id="parallel.alg.forloop">
      <h1>For loop</h1>

      <cxx-function>
        <cxx-signature>template&lt;class I, class... Rest&gt;
void for_loop(no_deduce_t&lt;I&gt; start, I finish, Rest&amp;&amp;... rest);</cxx-signature>

        <cxx-signature>template&lt;class ExecutionPolicy,
      class I, class... Rest&gt;
void for_loop(ExecutionPolicy&amp;&amp; exec,
              no_deduce_t&lt;I&gt; start, I finish, Rest&amp;&amp;... rest);

</cxx-signature>

        <cxx-signature>template&lt;class I, class S, class... Rest&gt;
void for_loop_strided(no_deduce_t&lt;I&gt; start, I finish,
                      S stride, Rest&amp;&amp;... rest);</cxx-signature>

        <cxx-signature>template&lt;class ExecutionPolicy,
      class I, class S, class... Rest&gt;
void for_loop_strided(ExecutionPolicy&amp;&amp; exec,
                      no_deduce_t&lt;I&gt; start, I finish,
                      S stride, Rest&amp;&amp;... rest);

</cxx-signature>

        <cxx-signature>template&lt;class I, class Size, class... Rest&gt;
void for_loop_n(I start, Size n, Rest&amp;&amp;... rest);</cxx-signature>

        <cxx-signature>template&lt;class ExecutionPolicy,
      class I, class Size, class... Rest&gt;
void for_loop_n(ExecutionPolicy&amp;&amp; exec,
                I start, Size n, Rest&amp;&amp;... rest);
          
</cxx-signature>

        <cxx-signature>template&lt;class I, class Size, class S, class... Rest&gt;
void for_loop_n_strided(I start, Size n, S stride, Rest&amp;&amp;... rest);</cxx-signature>

        <cxx-signature>template&lt;class ExecutionPolicy, 
      class I, class Size, class S, class... Rest&gt;
void for_loop_n_strided(ExecutionPolicy&amp;&amp; exec,
                        I start, Size n, S stride, Rest&amp;&amp;... rest);</cxx-signature>

        <cxx-requires>
          For the overloads with an <code>ExecutionPolicy</code>, <code>I</code> shall be an integral type
          or meet the requirements of a forward iterator type; otherwise, <code>I</code> shall be an integral
          type or meet the requirements of an input iterator type. <code>Size</code> shall be an integral type
          and <code>n</code> shall be non-negative. <code>S</code> shall have integral type and <code>stride</code>
          shall have non-zero value. <code>stride</code> shall be negative only if <code>I</code> has integral
          type or meets the requirements of a bidirectional iterator. The <code>rest</code> parameter pack shall
          have at least one element, comprising objects returned by invocations of <code>reduction</code>
          ([parallel.alg.reduction]) and/or <code>induction</code> ([parallel.alg.induction]) function templates
          followed by exactly one invocable element-access function, <em>f</em>. For the overloads with an
          <code>ExecutionPolicy</code>, <em>f</em> shall meet the requirements of <code>CopyConstructible</code>;
          otherwise, <em>f</em> shall meet the requirements of <code>MoveConstructible</code>.
        </cxx-requires>

        <cxx-effects>
          Applies <em>f</em> to each element in the <em>input sequence</em>, as described below, with additional
          arguments corresponding to the reductions and inductions in the <code>rest</code> parameter pack. The
          length of the input sequence is:

          <ul>
            <li>
              <code>n</code>, if specified,
            </li>

            <li>
              otherwise <code>finish - start</code> if neither <code>n</code> nor <code>stride</code> is specified,
            </li>

            <li>
              otherwise <code>1 + (finish-start-1)/stride</code> if <code>stride</code> is positive,
            </li>

            <li>
              otherwise <code>1 + (start-finish-1)/-stride</code>.
            </li>
          </ul>

          The first element in the input sequence is <code>start</code>. Each subsequent element is generated by adding
          <code>stride</code> to the previous element, if <code>stride</code> is specified, otherwise by incrementing
          the previous element. <cxx-note>As described in the C++ standard, section [algorithms.general], arithmetic
          on non-random-access iterators is performed using <code>advance</code> and <code>distance</code>.</cxx-note> <cxx-note>The order of the
          elements of the input sequence is important for determining ordinal position of an application of <em>f</em>,
          even though the applications themselves may be unordered.</cxx-note></p>

          The first argument to <em>f</em> is an element from the input sequence. <cxx-note>if <code>I</code> is an
          iterator type, the iterators in the input sequence are not dereferenced before
          being passed to <em>f</em>.</cxx-note> For each member of the <code>rest</code> parameter pack
          excluding <em>f</em>, an additional argument is passed to each application of <em>f</em> as follows:

          <ul>
            <li>
              If the pack member is an object returned by a call to a reduction function listed in section
              [parallel.alg.reductions], then the additional argument is a reference to an accumulator of that reduction
              object.
            </li>

            <li>
              If the pack member is an object returned by a call to <code>induction</code>, then the additional argument is the
              induction value for that induction object corresponding to the position of the application of <em>f</em> in the input
              sequence.
            </li>
          </ul>
        </cxx-effects>

        <cxx-complexity>
          Applies <em>f</em> exactly once for each element of the input sequence.
        </cxx-complexity>

        <cxx-remarks>
          If <em>f</em> returns a result, the result is ignored.
        </cxx-remarks>
      </cxx-function>
    </cxx-section>

    <cxx-section id="parallel.alg.novec">
      <h1>No vec</h1>

      <cxx-function>
        <cxx-signature>template&lt;class F&gt;
auto no_vec(F&amp;&amp; f) noexcept -&gt; decltype(std::forward&lt;F&gt;(f)());</cxx-signature>

        <cxx-effects>
          Evaluates <code>std::forward&lt;F&gt;(f)()</code>. When invoked within an element access function
          in a parallel algorithm using <code>vector_policy</code>, if two calls to <code>no_vec</code> are
          horizontally matched within a wavefront application of an element access function over input
          sequence S, then the execution of <code>f</code> in the application for one element in S is
          sequenced before the execution of <code>f</code> in the application for a subsequent element in
          S; otherwise, there is no effect on sequencing.
        </cxx-effects>

        <cxx-returns>
          <ins>T</ins><del>t</del>he result of <code>f</code>.
        </cxx-returns>

        <cxx-notes>
          If <code>f</code> exits via an exception, then <code>terminate</code> will be called, consistent
          with all other potentially-throwing operations invoked with <code>vector_policy</code> execution.

          <cxx-example>
            <pre>extern int* p;
for_loop(vec, 0, n[&amp;](int i) {
  y[i] +=y[i+1];
  if(y[i] &lt; 0) {
    no_vec([]{
      *p++ = i;
    });
  }
});</pre>

            The updates <code>*p++ = i</code> will occur in the same order as if the policy were <code>seq</code>.
          </cxx-example>
        </cxx-notes>
      </cxx-function>
    </cxx-section>

    <cxx-section id="parallel.alg.ordupdate.class">
      <h1>Ordered update class</h1>

<pre>
template&lt;class T&gt;
class ordered_update_t {
  T&amp; ref_; // exposition only
public:
  ordered_update_t(T&amp; loc) noexcept
    : ref_(loc) {}
  ordered_update_t(const ordered_update_t&amp;) = delete;
  ordered_update_t&amp; operator=(const ordered_update_t&amp;) = delete;

  template &lt;class U&gt;
    auto operator=(U rhs) const noexcept
      { return no_vec([&amp;]{ return ref_ = std::move(rhs); }); }
  template &lt;class U&gt;
    auto operator+=(U rhs) const noexcept
      { return no_vec([&amp;]{ return ref_ += std::move(rhs); }); }
  template &lt;class U&gt;
    auto operator-=(U rhs) const noexcept
      { return no_vec([&amp;]{ return ref_ -= std::move(rhs); }); }
  template &lt;class U&gt;
    auto operator*=(U rhs) const noexcept
      { return no_vec([&amp;]{ return ref_ *= std::move(rhs); }); }
  template &lt;class U&gt;
    auto operator/=(U rhs) const noexcept
      { return no_vec([&amp;]{ return ref_ /= std::move(rhs); }); }
  template &lt;class U&gt;
    auto operator%=(U rhs) const noexcept
      { return no_vec([&amp;]{ return ref_ %= std::move(rhs); }); }
  template &lt;class U&gt;
    auto operator&gt;&gt;=(U rhs) const noexcept
      { return no_vec([&amp;]{ return ref_ &gt;&gt;= std::move(rhs); }); }
  template &lt;class U&gt;
    auto operator&lt;&lt;=(U rhs) const noexcept
      { return no_vec([&amp;]{ return ref_ &lt;&lt;= std::move(rhs); }); }
  template &lt;class U&gt;
    auto operator&amp;=(U rhs) const noexcept
      { return no_vec([&amp;]{ return ref_ &amp;= std::move(rhs); }); }
  template &lt;class U&gt;
    auto operator^=(U rhs) const noexcept
      { return no_vec([&amp;]{ return ref_ ^= std::move(rhs); }); }
  template &lt;class U&gt;
    auto operator|=(U rhs) const noexcept
      { return no_vec([&amp;]{ return ref_ |= std::move(rhs); }); }

  auto operator++() const noexcept
    { return no_vec([&amp;]{ return ++ref_; }); }
  auto operator++(int) const noexcept
    { return no_vec([&amp;]{ return ref_++; }); }
  auto operator--() const noexcept
    { return no_vec([&amp;]{ return --ref_; }); }
  auto operator--(int) const noexcept
    { return no_vec([&amp;]{ return ref_--; }); }
};
</pre>

      <p>
      An object of type <code>ordered_update_t&lt;T&gt;</code> is a proxy for an object of type T
        intended to be used within a parallel application of an element access function using a
        policy object of type <code>vector_policy</code>. Simple increments, assignments, and compound
        assignments to the object are forwarded to the proxied object, but are sequenced as though
        executed within a <code>no_vec</code> invocation.

        <cxx-note>
          The return-value deduction of the forwarded operations results in these operations returning by
          value, not reference. This formulation prevents accidental collisions on accesses to the return
          value.
        </cxx-note>
      </p>
    </cxx-section>

    <cxx-section id="parallel.alg.ordupdate.func">
      <h1>Ordered update function template</h1>

      <cxx-function>
        <cxx-signature>template&lt;T&gt;
ordered_update_t&lt;T&gt; ordered_update(T&amp; loc) noexcept;</cxx-signature>

        <cxx-returns>
          <code>{ loc }</code>.
        </cxx-returns>
      </cxx-function>

    </cxx-section>
  </cxx-section>
</cxx-clause>
