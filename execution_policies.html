<cxx-clause id="parallel.execpol">
  <h1>Execution policies</h1>

  <cxx-section id="parallel.execpol.synopsis">
  <h1>Header <code>&lt;experimental/execution&gt;</code> synopsis</h1>

<pre>
#include &lt;execution&gt;

namespace std::experimental {
inline namespace parallelism_v2 {
namespace execution {
  <cxx-ref insynopsis="" to="parallel.execpol.unseq"></cxx-ref>
  class unsequenced_policy;

  <cxx-ref insynopsis="" to="parallel.execpol.vec"></cxx-ref>
  class vector_policy;

  <cxx-ref insynopsis="" to="parallel.execpol.objects"></cxx-ref>
  inline constexpr unsequenced_policy unseq{ <i>unspecified</i> };
  inline constexpr vector_policy vec{ <i>unspecified</i> };
}
}
}
</pre>
  </cxx-section>

  <cxx-section id="parallel.execpol.unseq">
    <h1>Unsequenced execution policy</h1>

<pre>
class unsequenced_policy{ <i>unspecified</i> };
</pre>

    <p>The class <code>unsequenced_policy</code> is an execution policy type used as a unique type to disambiguate parallel algorithm overloading and indicate that a parallel algorithm's execution may be vectorized, e.g., executed on a single thread using instructions that operate on multiple data items.</p>

    <p>The invocations of element access functions in parallel algorithms invoked with an execution policy of type <code>unsequenced_policy</code> are permitted to execute in an unordered fashion in the calling thread, unsequenced with respect to one another within the calling thread.
    <cxx-note>This means that multiple function object invocations may be interleaved on a single thread.</note></p>

    <p><cxx-note>This overrides the usual guarantee from the C++ Standard, <cxx-ref in="cxx" to="intro.execution"></cxx-ref> [intro.execution] that function executions do not overlap with one another.</cxx-note></p>

    <p>During the execution of a parallel algorithm with the <code>experimental::execution::unsequenced_policy</code> policy, if the invocation of an element access function exits via an uncaught exception, <code>terminate()</code> will be called.</p>

  </cxx-section>

  <cxx-section id="parallel.execpol.vec">
    <h1>Vector execution policy</h1>

<pre>
class vector_policy{ <i>unspecified</i> };
</pre>

    <p>The class <code>vector_policy</code> is an execution policy type used as a unique type to disambiguate parallel algorithm overloading and indicate that a parallel algorithm's execution may be vectorized. Additionally, such vectorization will result in an execution that respects the sequencing constraints of wavefront application (<a href="#parallel.alg.general.wavefront">[parallel.alg.general.wavefront]</a>). <cxx-note>The implementation thus makes stronger guarantees than for <code>unsequenced_policy</code>, for example.</cxx-note></p>

    <p>The invocations of element access functions in parallel algorithms invoked with an execution policy of type <code>vector_policy</code> are permitted to execute in unordered fashion in the calling thread, unsequenced with respect to one another within the calling thread, subject to the sequencing constraints of wavefront application (<a href="#parallel.alg.general.wavefront">[parallel.alg.general.wavefront]</a>) for the last argument to <code>for_loop</code>, <code>for_loop_n</code>, <code>for_loop_strided</code>, or <code>for_loop_strided_n</code>.</p>

    <p>During the execution of a parallel algorithm with the <code>experimental::execution::vector_policy</code> policy, if the invocation of an element access function exits via an uncaught exception, <code>terminate()</code> will be called.</p>

  </cxx-section>

  <cxx-section id="parallel.execpol.objects">
    <h1>Execution policy objects</h1>

<pre>
inline constexpr execution::unsequenced_policy unseq{ <i>unspecified</i> };
inline constexpr execution::vector_policy vec{ <i>unspecified</i> };
</pre>

    <p>The header <code>&lt;experimental/execution&gt;</code> declares a global object associated with each type of execution policy defined by this Technical Specification.</p>
  </cxx-section>
</cxx-clause>
